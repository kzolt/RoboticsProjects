#pragma config(Sensor, dgtl1,  FrontInput,     sensorSONAR_inch)
#pragma config(Sensor, dgtl3,  LeftInput,      sensorSONAR_inch)
#pragma config(Sensor, dgtl5,  RightInput,     sensorSONAR_inch)
#pragma config(Sensor, dgtl7,  BackInput,      sensorSONAR_inch)
#pragma config(Motor,  port3,           LeftMotor,     tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port4,           RightMotor,    tmotorVex393_MC29, openLoop, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
TODO
Check if the new system works
*/

#define FULL_SPEED 127
#define HALF_SPEED FULL_SPEED / 2
#define THIRD_SPEED FULL_SPEED / 3
#define QUARTER_SPEED FULL_SPEED / 4

#define SENSOR_AMOUNT 4

#define LEVEL_ONE 15
#define LEVEL_TWO 12
#define LEVEL_THREE 9
#define LEVEL_FOUR 6

/**************************************************
 * SRUCTS AND ENUMS
 **************************************************/

// Enumeration for how close something is
typedef enum sevarity
{
	NORMAL = 0,
	WARNING = 1,
	MINOR_DANGER = 2,
	DANGER = 3,
	FATAL = 4
} Sevarity;

// Enumeration for the location of the sensors
typedef enum loc
{
	FRONT = 0,
	BACK = 1,
	LEFT = 2,
	RIGHT = 3
} SensorLocation;

// sensor struct, holds a bunch of sensor information
typedef struct sensors
{
	int key;
	int value;
	Sevarity sevarity_level;
	SensorLocation sensor_location;
} Sensors;

// simple 2 dimensional vector
typedef struct vector
{
	int x, y;
} Vector2i;

// struct for robot
typedef struct robot
{
	int left_speed;
	int right_speed;
	Vector2i dir_vec;
	Sensors sensors[SENSOR_AMOUNT];
} Robot;

Robot rbot;

/**************************************************
 * INITIALIZATION
 **************************************************/

// Initializes sensors inside robot struct
void init_sensor(int key, SensorLocation loc)
{
	rbot.sensors[loc].key = key;
	rbot.sensors[loc].value = 0;
	rbot.sensors[loc].sevarity_level = NORMAL;
	rbot.sensors[loc].sensor_location = loc;
}

// Initializes Robot
void init_robot()
{
	rbot.left_speed = FULL_SPEED;
	rbot.right_speed = FULL_SPEED;
	rbot.dir_vec.x = 0;
	rbot.dir_vec.y = 0;

	init_sensor(FrontInput, FRONT);
	init_sensor(BackInput, BACK);
	init_sensor(LeftInput, LEFT);
	init_sensor(RightInput, RIGHT);
}

/**************************************************
 * FUNCTIONS
 **************************************************/

// Get's the values of the sensors and assigns sevarity according to location
void get_position_and_check_sevarity()
{
	// loops through sensors
	for (int i = 0; i < SENSOR_AMOUNT; i++)
	{
		// Assigns the current value of the sensor to value field
		rbot.sensors[i].value = SensorValue[rbot.sensors[i].key];

		// if the sensor is greater the "level one" then everything is a okay
		if (rbot.sensors[i].value > LEVEL_ONE)
			rbot.sensors[i].sevarity_level = NORMAL;

		// if the sensor is greater the "level one" then we should probably turn
		if (rbot.sensors[i].value <= LEVEL_ONE)
			rbot.sensors[i].sevarity_level = WARNING;

		// if the sensor is greater the "level two" then we should really turn
		if (rbot.sensors[i].value <= LEVEL_TWO)
			rbot.sensors[i].sevarity_level = MINOR_DANGER;

		// if the sensor is greater the "level three" then we should really turn
		if (rbot.sensors[i].value <= LEVEL_THREE)
			rbot.sensors[i].sevarity_level = DANGER;

		// if the sensor is greater the "level four" then we should definetly turn
		if (rbot.sensors[i].value <= LEVEL_FOUR)
			rbot.sensors[i].sevarity_level = FATAL;
	}
}

void add_vectors(int priority)
{
	// set both motors to be the same value
	if (rbot.sensors[priority].sensor_location == FRONT || rbot.sensors[priority].sensor_location == BACK)
	{
		rbot.left_speed = rbot.dir_vec.y;
		rbot.right_speed = rbot.dir_vec.y;
	}

	// slow down left motor because we want to turn left, keep right motor at same speed
	if (rbot.sensors[priority].sensor_location == LEFT)
	{
		rbot.left_speed = rbot.dir_vec.y;
		rbot.right_speed = rbot.dir_vec.y - rbot.dir_vec.x;
	}

	// slow down right motor because we want to turn right, keep left motor at same speed
	if (rbot.sensors[priority].sensor_location == RIGHT)
	{
		rbot.left_speed = rbot.dir_vec.y - rbot.dir_vec.x;
		rbot.right_speed = rbot.dir_vec.y;
	}
}

// Moves robot based off of what is closer
void adjust_robot()
{
	// check sevarity level of sensor and get the one with the highest sevarity
	int priority = 0;
	for (int i = 0; i < SENSOR_AMOUNT; i++)
	{
		if (rbot.sensors[i].sevarity_level > rbot.sensors[priority].sevarity_level)
			priority = i;
	}

	// adjust vector accordingly depending on sevarity
	switch (rbot.sensors[priority].sevarity_level)
	{
	case WARNING:
		// slow down if we are approaching something
		if (rbot.sensors[priority].sensor_location == FRONT)
		{
			rbot.dir_vec.y += QUARTER_SPEED;
			break;
		}

		// slow down if we are approaching something
		if (rbot.sensors[priority].sensor_location == BACK)
		{
			rbot.dir_vec.y -= QUARTER_SPEED;
			break;
		}

		// start turning if we are about to hit something
		if (rbot.sensors[priority].sensor_location == LEFT)
		{
			rbot.dir_vec.x -= QUARTER_SPEED;
			break;
		}

		// start turning if we are about to hit something
		if (rbot.sensors[priority].sensor_location == RIGHT)
			rbot.dir_vec.x += QUARTER_SPEED;

		break;
	case MINOR_DANGER:
		// really slow down if we are approaching something
		if (rbot.sensors[priority].sensor_location == FRONT)
		{
			rbot.dir_vec.y -= THIRD_SPEED;
			break;
		}

		// really slow down if we are approaching something
		if (rbot.sensors[priority].sensor_location == BACK)
		{
			rbot.dir_vec.y += THIRD_SPEED;
			break;
		}

		// really turn if we are going to hit something
		if (rbot.sensors[priority].sensor_location == LEFT)
		{
			rbot.dir_vec.x -= THIRD_SPEED;
			break;
		}

		// really turn if we are going to hit something
		if (rbot.sensors[priority].sensor_location == RIGHT)
				rbot.dir_vec.x += THIRD_SPEED;
		break;
	case DANGER:
		// genuinly slow down you mad man
		if (rbot.sensors[priority].sensor_location == FRONT)
		{
			rbot.dir_vec.y -= HALF_SPEED;
			break;
		}

		// genuinly slow down you mad man
		if (rbot.sensors[priority].sensor_location == BACK)
		{
			rbot.dir_vec.y += HALF_SPEED;
			break;
		}

		// omg turn
		if (rbot.sensors[priority].sensor_location == LEFT)
		{
			rbot.dir_vec.x += HALF_SPEED;
			break;
		}

		// omg turn
		if (rbot.sensors[priority].sensor_location == RIGHT)
				rbot.dir_vec.x -= HALF_SPEED;
		break;
	case FATAL:
		// jesus christ hit the breaks
		if (rbot.sensors[priority].sensor_location == FRONT)
		{
			rbot.dir_vec.y = -FULL_SPEED;
			break;
		}

		// jesus christ hit the breaks
		if (rbot.sensors[priority].sensor_location == BACK)
		{
			rbot.dir_vec.y = FULL_SPEED;
			break;
		}

		// swerve
		if (rbot.sensors[priority].sensor_location == LEFT)
		{
			rbot.dir_vec.x = FULL_SPEED;
			break;
		}

		// swerve
		if (rbot.sensors[priority].sensor_location == RIGHT)
				rbot.dir_vec.x = -FULL_SPEED;
		break;
	default:
		// Normal settings if everything is normal
		rbot.dir_vec.y = FULL_SPEED;
		rbot.dir_vec.x = 0;
		break;
	}

	add_vectors(priority);
}

void move_robot()
{
	// gets location of everything, sets sevarity
	get_position_and_check_sevarity();
	// adds vectors based off of sevarity and location
	adjust_robot();

	// sets actual motors to it's respected values
	motor[LeftMotor] = rbot.left_speed;
	motor[RightMotor] = rbot.right_speed;
}

task main()
{
	init_robot();

	while (true)
	{
		move_robot();
	}
}
